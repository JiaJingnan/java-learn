## MySQL数据库开发规范

### 一.基础规范

- **使用InnoDB 存储引擎**

没有特殊要求（即Innodb无法满足的功能如：列存储，存储空间数据等）的情况下，所有表必须使用Innodb存储引擎（mysql5.5之前默认使用Myisam，5.6以后默认的为Innodb）Innodb 支持事务，支持行级锁，更好的恢复性，高并发下性能更好

- **表字符集使用utf8mb4**

默认使用 utf8mb4 字符集，数据库排序规则使用 utf8mb4_general_ci，采用 utf8 编码的 MySQL 无法保存占位是 4 个字节的 Emoji 表情。为了使后端的项目全面支持客户端输入的 Emoji 表情，升级编码为 utf8mb4 是最佳解决方案；

兼容性更好，统一字符集可以避免由于字符集转换产生的乱码，不同的字符集进行比较前需要进行转换会造成索引失效

- **所有表都需要添加注释**

使用comment从句添加表和列的备注 从一开始就进行数据字典的维护 

- **单表数据量建议控制在500万以内**

500万并不是MySQL数据库的限制，过大会造成修改表结构，备份，恢复都会有很大的问题，可以用历史数据归档（应用于日志数据），分库分表（应用于业务数据）等手段来控制数据量大小

- **不在数据库中存储图、文件等大的二进制数据**

通常文件很大，会短时间内造成数据量快速增长，数据库进行数据库读取时，通常会进行大量的随机IO操作，文件很大时，IO操作很耗时 通常存储于文件服务器，数据库只存储文件地址信息 

- **尽量做到冷热数据分离，减小表的宽度**

MySQL限制每个表最多存储4096列，并且每一行数据的大小不能超过65535字节 减少磁盘IO,保证热数据的内存缓存命中率（表越宽，把表装载进内存缓冲池时所占用的内存也就越大,也会消耗更多的IO） 更有效的利用缓存，避免读入无用的冷数据 经常一起使用的列放到一个表中（避免更多的关联操作） 

- **禁止在线上做数据库压力测试**
- **禁止测试、开发环境直连数据库**

### 二. 命名规范

#### 1、库名、表名、字段名必须使用小写字母，并采用下划线分割

- MySQL有配置参数lower_case_table_names=1，即库表名以小写存储，大小写不敏感。如果是0，则库表名以实际情况存储，大小写敏感；如果是2，以实际情况存储，但以小写比较
- 如果大小写混合使用，可能存在abc，Abc，ABC等多个表共存，容易导致混乱
- 字段名显示区分大小写，但实际使用时不区分，即不可以建立两个名字一样但大小写不一样的字段
- 为了统一规范， 库名、表名、字段名使用小写字母，不允许 `-` 号

#### 2、库名、表名、字段名禁止超过32个字符，需见名知意，建议使用名词不是动词 

库名、表名、字段名支持最多64个字符，但为了统一规范、易于辨识以及减少传输量，禁止超过32个字符 

#### 3、**库名、表名、字段名禁止使用[MySQL保留字](https://dev.mysql.com/doc/refman/5.7/en/keywords.html)**

当库名、表名、字段名等属性含有保留字时，SQL语句必须用反引号引用属性名称，这将使得SQL语句书写、SHELL脚本中变量的转义等变得非常复杂。 

#### 4、临时库、表名必须以tmp为前缀，并以日期为后缀

形如：tmp_user_account_20190313

#### 5、备份库、表必须以bak为前缀，并以日期为后缀

形如：bak_user_account_20190313

#### 6、主键索引名为 pk_ 字段名；唯一索引名为 uk _ 字段名；普通索引名则为 idx_ 字段名

pk_ 即 primary key；uk_ 即 unique key；idx_ 即 index 的简称

#### 7、在不同的库或表中，要保证所有存储相同数据的列名和列类型必须一致

一般作为关联列，如果查询时关联列类型不一致会自动进行数据类型隐式转换，会造成列上的索引失效，导致查询效率降低 

#### 8、表的命名最好是加上“业务名称_表的作用”

正例：user_task / force_project / trade_config

### 三、字段设计规范

#### 1、优先选择符合存储需要的最小的数据类型

列的字段类型越大，建立索引占据的空间就越大，导致一个页中的索引越少，造成IO次数增加，影响性能

- 业务中选择性很少的状态`status`、类型`type`等字段推荐使用`tinytint`或者`smallint`类型节省存储空间
- 能用`int`的就不用`char`或者`varchar`
- 能用`tinyint`的就不用`int`
- 使用 **UNSIGNED** 存储非负数值 
- 使用`tinyint`来代替 `enum`和`boolean `
- 存储 ip 最好用 `int`存储而非 `char(15) `
- 表中的自增列（`auto_increment`属性），推荐使用`bigint`类型 

#### 2、不推荐使用`blob`，`text`等类型

`blob`，`text`是为了存储极大的字符串而设计的数据类型，采用二进制与字符串方式存储，该数据类型不能设置默认值、不便于排序、不便于建立索引， `varchar` 的性能会比 `text` 高很多，如果非要使用，建议将这种数据分离到单独的拓展表中

#### 3、禁止使用字符串来存储日期型数据

- 无法使用日期函数计算比较
- 字符串存储要占更多的内存空间，`datetime`(8字节)和`timestamp`(本身是以int存储，占4字节,范围:1970-01-01 00:00:01到2038-01-19 03:14:07)
- `TIMESTAMP` 记录经常变化的更新/创建/发布/日志时间等，并且是近来的时间，够用，可免时区处理
- `DATETIME` 记录生日、纪念事件、超出 `TIMESTAMP` 的时间，记得时区处理

#### 4、用 `DECIMAL` 代替 `FLOAT` 和 `DOUBLE` 存储精确浮点数

`Decimal`类型为精准浮点数，`float` 和 `double` 在存储的时候，存在精度损失的问题，很可能在值的比较时，得到不正确的结果。如果存储的数据范围超过 decimal 的范围，建议将数据拆成整数和小数分开存储。

#### 5、必须把字段定义为NOT NULL并设默认值 

- NULL的列使用索引，索引统计，值都更加复杂，MySQL更难优化 
- NULL需要更多的存储空间
- NULL只能采用IS NULL或者IS NOT NULL，而在=/!=/in/not in时有大坑

#### 6、使用varchar(20)存储手机号，不要使用整数

- 牵扯到国家代号，可能出现+/-/()等字符，例如+86
- 手机号不会用来做数学运算
- varchar可以模糊查询，例如like ‘138%’ 

#### 7、根据业务区分使用char/varchar

- 字段长度固定，或者长度近似的业务场景，适合使用char，能够减少碎片，查询性能高
- 字段长度相差较大，或者更新较少的业务场景，适合使用varchar，能够减少空间

#### 8、禁止在数据库中存储明文密码，把密码加密后存储

#### 9、尽量不使用外键

建议在应用层实现外键的逻辑， 外键与级联更新不适合高并发场景，降低插入性能，大并发下容易产生死锁

#### 10、整形定义中不添加长度，比如使用INT，而不是INT[4]

值类型括号后面的数字只是表示宽度而跟存储范围没有关系

### 四、索引设计规范

索引其实就是一种数据结构，（哈希表、树等等）不同类型的索引有着不同的数据结构和功能。

MySQL的查询速度依赖良好的索引设计，因此索引对于高性能至关重要。合理的索引会加快查询速度，不合理的索引会降低速度

#### 0、索引的作用

- 加速查询速度
- 维护数据的约束性（完整性、一致性）

> 对于加速查询，使用索引不一定是最好的选择。小表就直接全表扫描，中到大表就建索引，超大表就分区分表。其实主要就要索引带来的好处和维护索引的成本之间的权衡。 

#### 1、单表的索引数建议不超过 5 个，单个索引中的字段数建议不超过 5 个 

太多就起不到过滤作用了，索引也占空间，管理起来也耗资源

#### 2、对字符串使用前缀索引，前缀索引长度不超过8个字符

不要索引blob/text等字段，不要索引大型字段，这样做会让索引占用太多的存储空间

> 前缀索引就是对文本的前几个字符建立索引，前缀索引能有效减小索引文件的大小，提高索引的速度。但是前缀索引也有它的坏处：MySQL 不能在 ORDER BY 或 GROUP BY 中使用前缀索引，也不能把它们用作覆盖索引(Covering Index)

#### 3、主键准则

- 表必须有主键
- 不使用更新频繁的列
- 尽量不选择字符串列
- 不使用UUID MD5 HASH
- 默认使用非空的唯一键
- 建议选择自增或发号器

#### 4、重要的SQL必须被索引，核心SQL优先考虑覆盖索索引

- UPDATE、DELETE 语句的 WHERE 条件列
- ORDER BY、GROUP BY、DISTINCT 的字段
- 多表 JOIN 的字段

#### 5、区分度最大的字段放在前面

- 选择筛选性更优的字段放在最前面，比如单号、userid等，type，status等筛选性一般不建议放在最前面
- 索引根据左前缀原则，当建立一个联合索引(a,b,c)，则查询条件里面只有包含(a)或(a,b)或(a,b,c)的时候才能走索引，(a,c)作为条件的时候只能使用到a列索引，所以这个时候要确定a的返回列一定不能太多，不然语句设计就不合理，(b,c)则不能走索引

#### 00、MYSQL 中索引的限制

- MYISAM 存储引擎索引长度的总和不能超过 1000 字节
- BLOB 和 TEXT 类型的列只能创建前缀索引
- 使用不等于 (!= 或者 <>) 的时候, MYSQL 无法使用索引
- 过滤字段使用函数运算 (如 abs (column)) 后, MYSQL无法使用索引
- join语句中join条件字段类型不一致的时候MYSQL无法使用索引
- 使用 LIKE 操作的时候如果条件以通配符开始 (如 ‘%abc…’)时, MYSQL无法使用索引。
- 使用非等值查询的时候, MYSQL 无法使用 Hash 索引



### 五、SQL查询规范

#### 1、按需索取，拒绝 `select *` 

- 无法索引覆盖，回表操作，增加 io
- 额外的内存负担，大量冷数据灌入`innodb_buffer_pool_size`，降低查询命中率 
- 额外的网络传输开销

#### 2、能确定返回结果只有一条时，使用 limit 1

**在保证数据不会有误的前提下**，能确定结果集数量时，多使用limit，尽快的返回结果。

#### 3、涉及到复杂sql时，务必先参考已有索引设计，先explain

- 简单SQL拆分，不以代码处理复杂为由
- 比如 OR 条件： f_phone=’10000’ or f_mobile=’10000’，两个字段各自有索引，但只能用到其中一个。可以拆分成2个sql，或者union all
- 先explain的好处是可以为了利用索引，增加更多查询限制条件





### 参考文章

[MySQL命名、设计及使用规范](https://www.biaodianfu.com/mysql-best-practices.html)

[MySQL数据库开发规范-EC](http://seanlook.com/2016/05/11/mysql-dev-principle-ec/)

https://www.cnblogs.com/huchong/p/10219318.html

http://www.runoob.com/mysql/mysql-data-types.html

https://www.cnblogs.com/52fhy/p/9615551.html

https://learnku.com/articles/25020

[MySQL 表与索引设计攻略](https://futu.im/article/mysql/)

https://blog.csdn.net/xlgen157387/article/details/48086607

https://blog.csdn.net/caohao1210/article/details/88193599

[深入浅出分析MySQL索引设计背后的数据结构](https://www.cnblogs.com/mysql-dba/p/6689597.html)

[云数据库 MySQL 使用规范](https://cloud.tencent.com/document/product/236/13390)

[MySQL 索引 | 菜鸟教程](http://www.runoob.com/mysql/mysql-index.html)

[【MySQL优化】1、定位问题](https://blog.csdn.net/tian330726/article/details/83111280)

[在线 B+树 生成器](https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html)

### 附录

**MySQL数据类型**

MySQL支持多种类型，大致可以分为三类：**数值**、**日期/时间 **和 **字符串(字符)**类型。 

#### 数值类型

MySQL支持所有标准SQL数值数据类型。

这些类型包括严格数值数据类型(`INTEGER`、`SMALLINT`、`DECIMAL`和`NUMERIC`)，以及近似数值数据类型(`FLOAT`、`REAL`和`DOUBLE PRECISION`)。

关键字`INT`是`INTEGER`的同义词，关键字`DEC`是`DECIMAL`的同义词。

`BIT`数据类型保存位字段值，并且支持MyISAM、MEMORY、InnoDB和BDB表。

作为SQL标准的扩展，MySQL也支持整数类型`TINYINT`、`MEDIUMINT`和`BIGINT`。下面的表显示了需要的每个整数类型的存储和范围。

| 类型         | 大小                                   | 范围（有符号）                                               | 范围（无符号）                                               | 用途            |
| ------------ | -------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | --------------- |
| TINYINT      | 1 字节                                 | (-128，127)                                                  | (0，255)                                                     | 小整数值        |
| SMALLINT     | 2 字节                                 | (-32 768，32 767)                                            | (0，65 535)                                                  | 大整数值        |
| MEDIUMINT    | 3 字节                                 | (-8 388 608，8 388 607)                                      | (0，16 777 215)                                              | 大整数值        |
| INT或INTEGER | 4 字节                                 | (-2 147 483 648，2 147 483 647)                              | (0，4 294 967 295)                                           | 大整数值        |
| BIGINT       | 8 字节                                 | (-9,223,372,036,854,775,808，9 223 372 036 854 775 807)      | (0，18 446 744 073 709 551 615)                              | 极大整数值      |
| FLOAT        | 4 字节                                 | (-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38) | 0，(1.175 494 351 E-38，3.402 823 466 E+38)                  | 单精度 浮点数值 |
| DOUBLE       | 8 字节                                 | (-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) | 0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) | 双精度 浮点数值 |
| DECIMAL      | DECIMAL(M,D) ，如果M>D，为M+2否则为D+2 | 依赖于M和D的值                                               | 依赖于M和D的值                                               | 小数值          |

#### 日期和时间类型

表示时间值的日期和时间类型为`DATETIME`、`DATE`、`TIMESTAMP`、`TIME`和`YEAR`。

每个时间类型有一个有效值范围和一个"零"值，当指定不合法的MySQL不能表示的值时使用"零"值。

`TIMESTAMP`类型有专有的自动更新特性，将在后面描述。

| 类型      | 大小 (字节) | 范围                                                         | 格式                | 用途                     |
| --------- | ----------- | ------------------------------------------------------------ | ------------------- | ------------------------ |
| DATE      | 3           | 1000-01-01/9999-12-31                                        | YYYY-MM-DD          | 日期值                   |
| TIME      | 3           | '-838:59:59'/'838:59:59'                                     | HH:MM:SS            | 时间值或持续时间         |
| YEAR      | 1           | 1901/2155                                                    | YYYY                | 年份值                   |
| DATETIME  | 8           | 1000-01-01 00:00:00/9999-12-31 23:59:59                      | YYYY-MM-DD HH:MM:SS | 混合日期和时间值         |
| TIMESTAMP | 4           | 1970-01-01 00:00:00/2038结束时间是第 **2147483647** 秒，北京时间 **2038-1-19 11:14:07**，格林尼治时间 2038年1月19日 凌晨 03:14:07 | YYYYMMDD HHMMSS     | 混合日期和时间值，时间戳 |

#### 字符串类型

字符串类型指`CHAR`、`VARCHAR`、`BINARY`、`VARBINARY`、`BLOB`、`TEXT`、`ENUM`和`SET`

| 类型       | 大小                | 用途                            |
| ---------- | ------------------- | ------------------------------- |
| CHAR       | 0-255字节           | 定长字符串                      |
| VARCHAR    | 0-65535 字节        | 变长字符串                      |
| TINYBLOB   | 0-255字节           | 不超过 255 个字符的二进制字符串 |
| TINYTEXT   | 0-255字节           | 短文本字符串                    |
| BLOB       | 0-65 535字节        | 二进制形式的长文本数据          |
| TEXT       | 0-65 535字节        | 长文本数据                      |
| MEDIUMBLOB | 0-16 777 215字节    | 二进制形式的中等长度文本数据    |
| MEDIUMTEXT | 0-16 777 215字节    | 中等长度文本数据                |
| LONGBLOB   | 0-4 294 967 295字节 | 二进制形式的极大文本数据        |
| LONGTEXT   | 0-4 294 967 295字节 | 极大文本数据                    |

#### MySQL之`varchar`的设计

- **存储规则：** 

4.0版本以下，varchar(20)，指的是20**字节**，如果存放UTF8汉字时，只能存6个（每个汉字3字节）  

5.0版本以上，varchar(20)，指的是20**字符**，无论存放的是数字、字母还是UTF8汉字（每个汉字3字节），都可以存放20个，最大大小是65532字节 

- **限制规则**

1）存储限制 

varchar 字段是将实际内容单独存储在聚簇索引之外，内容开头用1到2个字节表示实际长度，小于255为1个字节，大于255则要2个字节

2）编码长度限制

字符类型若为gbk，每个字符最多占2个字节，最大长度不能超过32766

字符类型若为utf8，每个字符最多占3个字节，最大长度不能超过21845

字符类型若为utf8mb4，每个字符最多占4个字节，最大长度不能超过16383

3）表长度限制

mysql的一个表总共字段长度不超过65535

- **varchar(10)和varchar(100)的区别**

保存"hello"时占用的空间是一样的，但是更小的varchar(10)有着更好的性能

比如：MySQL建立索引时如果没有限制索引的大小，索引长度会默认采用的该字段的长度，也就是varchar(100)建立的索引存储大小要比varchar(10)建立索引存储大小大的多，加载索引使用的内存也更多



#### 位、字节、字符的区别

位（`bit`）：计算机存储信息的最小单位，二进制的一个“0”或一个“1”叫一位 

字节（`byte`）：是计算机中数据处理的基本单位，习惯上用大写  B  来表示，1B（byte,字节）= 8bit（位）

字符：是指计算机中使用的字母、数字、字和符号，不同的编码里，一个字符对应几个字节是不同的

**ASCIIS码**： 1个英文字母（不分大小写）= 1个字节的空间

​                    1个中文汉字 = 2个字节的空间

​                    1个ASCII码 = 一个字节

**UTF-8编码**：1个英文字符 = 1个字节

​                     英文标点  = 1个字节

​                     1个中文（含繁体） = 3个字节

​                     中文标点 = 3个字节

**utf8mb4** ：中文 = 3个字节

​		    emoji表情符号 = 4个字节

#### 索引种类

根据数据库的功能，可以分以下索引类型：

- **唯一索引**

唯一索引是不允许其中任何两行具有相同索引值的索引，加速查询 + 列值唯一（可以有null） 

```mysql
ALTER TABLE `table_name` ADD UNIQUE uk_xxx (`column` ) 
```

- **主键索引**

加速查询 + 列值唯一（不可以有null）+ 表中只有一个
在数据库中为表定义主键将自动创建主键索引，主键索引是唯一索引的特定类型，该索引要求主键中的每个值都唯一

```mysql
ALTER TABLE `table_name` ADD PRIMARY KEY (`column`) 
```

- **聚集索引**

查询列要被所建的索引覆盖；在聚集索引中，表中行的物理顺序与键值的逻辑（索引）顺序相同，一个表只能包含一个聚集索引，主键就是一个聚集索引

- **组合索引**

多列值组成一个索引，专门用于组合搜索，其效率大于索引合并

```mysql
ALTER TABLE `table_name` ADD INDEX idx_xxx (`column1`, `column2`, `column3`)
```

- **普通索引**

```mysql
ALTER TABLE `table_name` ADD INDEX idx_xxx (`column`)
```

- **全文索引**

```mysql
ALTER TABLE `table_name` ADD FULLTEXT (`column`)
```

- **覆盖索引**

InnoDB存储引擎中，secondary index（非主键索引）中没有直接存储行地址，存储主键值。如果用户需要查询secondary index中所不包含的数据列时，需要先通过secondary index查找到主键值，然后再通过主键查询到其他数据列，因此需要查询两次。覆盖索引的概念就是查询可以通过在一个索引中完成，覆盖索引效率会比较高，主键查询是天然的覆盖索引。合理的创建索引以及合理的使用查询语句，当使用到覆盖索引时可以获得性能提升。比如SELECT email,uid FROM user_email WHERE uid=xx，如果uid不是主键，适当时候可以将索引添加为index(uid,email)，以获得性能提升

#### 较为规范的建表语句

```mysql
CREATE TABLE `user` (
  `id` bigint(11) NOT NULL AUTO_INCREMENT,
  `user_id` bigint(11) NOT NULL COMMENT '用户id',
  `username` varchar(45) NOT NULL COMMENT '真实姓名',
  `email` varchar(30) NOT NULL COMMENT '用户邮箱',
  `nickname` varchar(45) NOT NULL COMMENT '昵称',
  `avatar` int(11) NOT NULL COMMENT '头像',
  `birthday` date NOT NULL COMMENT '生日',
  `sex` tinyint(4) DEFAULT '0' COMMENT '性别',
  `short_introduce` varchar(150) DEFAULT NULL COMMENT '一句话介绍自己，最多50个汉字',
  `user_resume` varchar(300) NOT NULL COMMENT '用户提交的简历存放地址',
  `user_register_ip` int(11) NOT NULL COMMENT '用户注册时的源ip',
  `create_time` timestamp NOT NULL COMMENT '用户记录创建的时间',
  `update_time` timestamp NOT NULL COMMENT '用户资料修改的时间',
  `user_review_status` tinyint(4) NOT NULL COMMENT '用户资料审核状态，1为通过，2为审核中，3为未通过，4为还未提交审核',
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_user_id` (`user_id`),
  KEY `idx_username` (`username`),
  KEY `idx_create_time` (`create_time`,`user_review_status`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci COMMENT='网站用户基本信息'
```




